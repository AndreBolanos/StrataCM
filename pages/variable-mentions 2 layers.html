<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>@ Tag Autocomplete (Categories → Variables)</title>

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>





  <style>
    body {
      background: #f8f9fa;
      padding: 40px;
    }

    textarea {
      width: 100%;
      min-height: 120px;
    }

    #dropdownBox {
      position: absolute;
      z-index: 10000;
      display: none;
      min-width: 220px;
      max-height: 260px;
      overflow-y: auto;
    }

    #mirror {
      position: absolute;
      top: 0;
      left: -9999px;
      visibility: hidden;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
  </style>
</head>

<body>
  <div class="container">
    <h4 class="mb-4">@Category.variable with Bootstrap dropdown</h4>

    <div class="mb-2 d-flex gap-2">
      <div style="flex:1">
        <label class="form-label fw-bold">Templates</label>
        <select id="templateSelector" class="form-select form-select-sm"></select>
      </div>

      <div class="d-flex align-items-end gap-2">
        <button id="btnClear" class="btn btn-sm btn-secondary">Clear</button>
        <button id="btnSaveTemplate" class="btn btn-sm btn-primary">Save as Template</button>
        <button id="btnGenerateDoc" class="btn btn-sm btn-success">Download Word</button>

      </div>
    </div>


    <div>
      <textarea id="ta" class="form-control"
        placeholder="Type @Supervisor.name, @Employee.email, @Provider.companyName ..." rows="10"></textarea>
      <div id="dropdownBox" class="dropdown-menu show shadow"></div>
      <div id="mirror"></div>
    </div>

    <h5 class="mt-4">Preview Output:</h5>
    <div id="preview" class="p-3 bg-white border rounded" style="min-height:80px;">
      <em class="text-muted">Nothing to preview</em>
    </div>
    <button id="btnClearTemplates" class="btn btn-sm btn-danger mt-2 float-end">Delete Templates</button>
  </div>



  <script>
    const templates = {
      "Select Template": "",
      "Letter to Employee": `Hello @Employee.name,

We have received your documentation. If we need any clarification, we will contact you at @Employee.email or @Employee.phone.

Regards,
@Supervisor.name`,

      "Nurse Triage Report": `Nurse triage completed.

Supervisor assigned: @Supervisor.name
Employee involved: @Employee.name

Case is located in @Provider.city, @Provider.country.

Please review this report.`,

      "Provider Contact": `Hello,

I am contacting @Provider.companyName located in @Provider.city, @Provider.country.

Supervisor email reference: @Supervisor.email

Thank you`
    };


    const data = {
      Supervisor: {
        name: "Alfredo Cea",
        email: "alfredo@example.com",
        phone: "+502-5555-0000"
      },
      Employee: {
        name: "André Bolaños",
        email: "andre@example.com",
        phone: "+502-5555-1111"
      },
      Provider: {
        companyName: "TechCorp",
        city: "Guatemala City",
        country: "Guatemala"
      }
    };

    // optional legacy
    const legacy = {
      username: "André Bolaños",
      email: "andre@example.com",
      city: "Guatemala City",
      phone: "+502 5555-5555",
      country: "Guatemala",
      company: "TechCorp",
      address: "4827 Maplewood Drive, Springfield, IL 62704, USA",
      supervisor: "Alfredo Cea",
    };

    const ta = document.getElementById('ta');
    const dropdown = document.getElementById('dropdownBox');
    const mirror = document.getElementById('mirror');
    const preview = document.getElementById('preview');

    function getCaretCoordinates(textarea, position) {
      const style = window.getComputedStyle(textarea);
      mirror.style.cssText = '';
      mirror.style.position = 'absolute';
      mirror.style.visibility = 'hidden';
      mirror.style.whiteSpace = 'pre-wrap';
      mirror.style.wordWrap = 'break-word';
      const props = [
        'fontFamily', 'fontSize', 'fontWeight', 'lineHeight',
        'padding', 'border', 'whiteSpace', 'letterSpacing'
      ];
      props.forEach(p => mirror.style[p] = style[p]);
      mirror.style.width = style.width;
      let upto = textarea.value.substring(0, position);
      mirror.textContent = upto;
      const span = document.createElement('span');
      span.textContent = '\u200b';
      mirror.appendChild(span);
      const mirrorRect = mirror.getBoundingClientRect();
      const spanRect = span.getBoundingClientRect();
      const inputRect = textarea.getBoundingClientRect();
      const lineHeight = parseFloat(style.lineHeight) || 16;
      return {
        top: inputRect.top + (spanRect.top - mirrorRect.top) - textarea.scrollTop + lineHeight,
        left: inputRect.left + (spanRect.left - mirrorRect.left) - textarea.scrollLeft
      };
    }

    function showDropdownAt(coords, items, onSelect) {
      dropdown.innerHTML = '';
      items.forEach(it => {
        const a = document.createElement('a');
        a.href = '#';
        a.className = 'dropdown-item';
        a.textContent = it;
        a.onclick = e => { e.preventDefault(); onSelect(it); };
        dropdown.appendChild(a);
      });
      dropdown.style.left = coords.left + 'px';
      dropdown.style.top = coords.top + 'px';
      dropdown.style.display = 'block';
    }

    function hideDropdown() { dropdown.style.display = 'none'; }

    function getCurrentAtToken(text, caretPos) {
      const upto = text.slice(0, caretPos);
      const at = upto.lastIndexOf('@');
      if (at === -1) return null;
      const token = upto.slice(at, caretPos);
      if (/\s/.test(token)) return null;
      return { start: at, value: token };
    }

    function replaceRange(original, start, end, insertText) {
      return original.slice(0, start) + insertText + original.slice(end);
    }

    function findRealCategoryName(userTyped) {
      const lowerTyped = userTyped.toLowerCase();
      for (const realCat of Object.keys(data)) {
        if (realCat.toLowerCase() === lowerTyped) return realCat;
      }
      return null;
    }

    function insertCategory(catInput, tokenStart, caretPos) {
      const catName = findRealCategoryName(catInput) || catInput;
      const newText = replaceRange(ta.value, tokenStart, caretPos, '@' + catName + '.');
      const newCaretPos = tokenStart + ('@' + catName + '.').length;
      ta.value = newText;
      setCaretPosition(ta, newCaretPos);
      updatePreview();
      ta.focus();

      // IMPORTANT: show variable dropdown next tick (allows caret to update)
      setTimeout(() => {
        showVariableDropdown(catName, "");
      }, 0);
    }


    function insertVariable(catName, variableKey, tokenStart, caretPos, typedAfterDot = '') {
      const finalTag = '@' + catName + '.' + variableKey;
      const newText = replaceRange(ta.value, tokenStart, caretPos, finalTag + ' ');
      const newCaretPos = tokenStart + finalTag.length + 1;
      ta.value = newText;
      setCaretPosition(ta, newCaretPos);
      hideDropdown();
      updatePreview();
      ta.focus();
    }

    function setCaretPosition(el, pos) { el.focus(); el.setSelectionRange(pos, pos); }

    function showCategoryDropdown(filter = '') {
      const cats = Object.keys(data).filter(c => c.toLowerCase().startsWith(filter.toLowerCase()));
      const caretPos = ta.selectionStart;
      const coords = getCaretCoordinates(ta, caretPos);
      showDropdownAt(coords, cats, (picked) => {
        const token = getCurrentAtToken(ta.value, ta.selectionStart);
        if (!token) return hideDropdown();
        insertCategory(picked, token.start, ta.selectionStart);
      });
    }

    function showVariableDropdown(catName, filter = '') {
      const keys = Object.keys(data[catName] || {}).filter(k => k.toLowerCase().startsWith(filter.toLowerCase()));
      const caretPos = ta.selectionStart;
      const coords = getCaretCoordinates(ta, caretPos);
      showDropdownAt(coords, keys, (picked) => {
        const token = getCurrentAtToken(ta.value, ta.selectionStart);
        if (!token) return hideDropdown();
        const tokenBody = token.value.slice(1);
        const dotIdx = tokenBody.indexOf('.');
        const typedAfterDot = dotIdx >= 0 ? tokenBody.slice(dotIdx + 1) : '';
        insertVariable(catName, picked, token.start, ta.selectionStart, typedAfterDot);
      });
    }

    ta.addEventListener('input', () => {
      const caretPos = ta.selectionStart;
      const token = getCurrentAtToken(ta.value, caretPos);
      if (!token) { hideDropdown(); updatePreview(); return; }
      const core = token.value.slice(1);
      const dotIdx = core.indexOf('.');
      if (dotIdx === -1) {
        showCategoryDropdown(core);
      } else {
        const rawCat = core.slice(0, dotIdx);
        const varQuery = core.slice(dotIdx + 1);
        const catName = findRealCategoryName(rawCat) || rawCat;
        if (!data[catName]) {
          showCategoryDropdown(rawCat);
        } else {
          showVariableDropdown(catName, varQuery);
        }
      }
      updatePreview();
    });

    document.addEventListener('click', e => {
      if (!dropdown.contains(e.target) && e.target !== ta) hideDropdown();
    });

    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') hideDropdown();
    });

    function updatePreview() {
      const raw = ta.value;
      if (raw.trim() === "") { preview.innerHTML = "<em class='text-muted'>Nothing to preview</em>"; return; }
      let rendered = raw.replace(/@([A-Za-z][A-Za-z0-9]*)\.([A-Za-z][A-Za-z0-9_]*)/g, (m, cat, key) => {
        const realCat = findRealCategoryName(cat) || cat;
        const val = data?.[realCat]?.[key];
        return `<strong>${val ?? m}</strong>`;
      });
      rendered = rendered.replace(/@([A-Za-z][A-Za-z0-9_]*)/g, (m, key) => {
        const val = legacy?.[key];
        return `<strong>${val ?? m}</strong>`;
      });
      rendered = rendered.replace(/\n/g, '<br>');
      preview.innerHTML = rendered;
    }

    // ---------- TEMPLATE DROPDOWN ----------
    const templateSelector = document.getElementById("templateSelector");

    // populate template list
    Object.keys(templates).forEach(t => {
      const opt = document.createElement("option");
      opt.value = t;
      opt.textContent = t;
      templateSelector.appendChild(opt);
    });

    // on select → load into textarea
    templateSelector.addEventListener("change", () => {
      const selected = templateSelector.value;
      ta.value = templates[selected] || "";
      ta.focus();
      updatePreview();
    });

    // --- LOCAL STORAGE TEMPLATE SUPPORT ---
    function loadLocalTemplates() {
      const stored = JSON.parse(localStorage.getItem("customTemplates") || "{}");
      return stored;
    }

    function saveLocalTemplates(obj) {
      localStorage.setItem("customTemplates", JSON.stringify(obj));
    }

    // merge default templates + local templates in dropdown
    function rebuildTemplateSelector() {
      templateSelector.innerHTML = "";
      const fullList = { ...templates, ...loadLocalTemplates() };
      Object.keys(fullList).forEach(t => {
        const opt = document.createElement("option");
        opt.value = t;
        opt.textContent = t;
        templateSelector.appendChild(opt);
      });
    }
    rebuildTemplateSelector();


    // SELECT template loads into textarea
    templateSelector.addEventListener("change", () => {
      const selected = templateSelector.value;
      const stored = { ...templates, ...loadLocalTemplates() };
      ta.value = stored[selected] || "";
      ta.focus();
      updatePreview();
    });


    // CLEAR button
    document.getElementById("btnClear").addEventListener("click", () => {
      templateSelector.value = "Select Template";
      ta.value = "";
      updatePreview();
      ta.focus();
    });


    // SAVE NEW TEMPLATE button
    document.getElementById("btnSaveTemplate").addEventListener("click", () => {
      const name = prompt("Template name:");
      if (!name) return;

      const body = ta.value;
      if (!body.trim()) {
        alert("Cannot save empty template.");
        return;
      }

      const stored = loadLocalTemplates();
      stored[name] = body;
      saveLocalTemplates(stored);
      rebuildTemplateSelector();
      templateSelector.value = name;
      alert("Template saved!");
    });

    document.getElementById("btnClearTemplates").addEventListener("click", () => {
      if (!confirm("Delete ALL custom templates?")) return;
      localStorage.removeItem("customTemplates");
      rebuildTemplateSelector();
      alert("All saved templates deleted.");
    });


    // ------- GENERATE WORD DOC (REPLACED CONTENT, PRESERVE <strong>) -------
    document.getElementById("btnGenerateDoc").addEventListener("click", async () => {
      if (!window.docx) {
        alert("docx library not loaded");
        return;
      }
      const { Document, Packer, Paragraph, TextRun } = window.docx;

      // Take the already-replaced HTML from the preview
      const html = preview.innerHTML;

      // Turn simple HTML (<br> and <strong>) into Paragraph + TextRun[]
      function htmlToParagraphs(htmlString) {
        // Normalize <br> variants to \n
        const normalized = htmlString.replace(/<br\s*\/?>/gi, "\n");

        // Split into lines; each becomes a Paragraph
        return normalized.split("\n").map(line => {
          const runs = [];
          // Very small inline parser: split by <strong>…</strong>
          // Keep the strong content bold; everything else regular
          const parts = line.split(/(<strong>.*?<\/strong>)/gi);
          parts.forEach(part => {
            if (!part) return;
            const strongMatch = part.match(/^<strong>(.*?)<\/strong>$/i);
            if (strongMatch) {
              runs.push(new TextRun({ text: decodeHTML(strongMatch[1]), bold: true }));
            } else {
              // Strip any other tags (there shouldn't be others)
              const plain = part.replace(/<\/?[^>]+>/g, "");
              if (plain) runs.push(new TextRun({ text: decodeHTML(plain) }));
            }
          });
          return new Paragraph({ children: runs.length ? runs : [new TextRun("")] });
        });
      }

      // Decode a couple of common HTML entities (&amp; &lt; &gt; &quot; &#39;)
      function decodeHTML(s) {
        return s
          .replace(/&amp;/g, "&")
          .replace(/&lt;/g, "<")
          .replace(/&gt;/g, ">")
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'");
      }

      const paragraphs = htmlToParagraphs(html);

      const doc = new Document({
        sections: [{ properties: {}, children: paragraphs }]
      });

      const filename = prompt("File name:", "template.docx") || "template.docx";
      const blob = await Packer.toBlob(doc);
      saveAs(blob, filename);
    });


  </script>

</body>

</html>